\chapter{Engineering}

\section{Documentation}

\subsection{Doxygen}

Doxygen - create html documentation based on your codebase

\section{Unit Testing}

\subsection{Catch2}

\section{Code Coverage}

\section{Continuous Integration}

\subsection{Github Actions}



\section{Installation Commands}

\begin{verbatim}
sudo apt-get update
sudo apt-get upgrade

gcc g++ gdb
make cmake
git
doxygen
python3 python3-pip
lcov gcovr
ccache
cppcheck
llvm clang-format clang-tidy
curl zip unzip tar

# for VSCODE

in extension, download franneck94 c/c++ extension pack
And the coding tools extension pack
Then, with command palette (in view), Config: generate C config file. It configures all tools the same as the
teacher's
\end{verbatim}

\section{Builds}

\subsection{Build Configuration (build target)}

\begin{verbatim}
    Project settings determining how your project will be built. 
    Build configuration includes executable name, project arch and library files. 
    It specifies keepings or strippings of debugging info, compiler optimization details 
\end{verbatim}

\subsection{Build Release Configuration}

\begin{verbatim}
    Optimized for size and performance, no debugging information.
    With all optimization, now testing for code performance.

    When the Hello World program (from lesson 0.7) was built using Visual Studio,
    Executable produced in the debug configuration was 65kb, 
    Executable built in the release version was 12kb. 
    The difference is largely due to the extra debugging information kept in the debug build.
\end{verbatim}


\subsection{Build Testing Configuration}

\begin{verbatim}
    Debug configuations turns off all optimizations, includes debugging information,
    Jason Turner would say "with as much information as possible"
    Such configs makes your programs larger and slower, but much easier to debug. 
\end{verbatim}

\subsection{G++ Builds}
\begin{verbatim}
GCC / Clang? 
    -ggdb  // cmd line debugging
           // This is the GNU Debugger !?
    -ggdb O2 -DNDEBUG for release builds. ??
    -g++ O2 -DNDEBUG for release builds. ??
\end{verbatim}

\section{Debugging}

\begin{verbatim}
    Debug configuations turns off all optimizations, includes debugging information,
    Jason Turner would say "with as much information as possible"
    Such configs makes your programs larger and slower, but much easier to debug. 
\end{verbatim}

\section{GDB}
\section{Testing Framework Catch2}

\section{Benchmarking}

\section{Synch}
\section{Asynch}
\section{Threads}
\subsection{Multithreading - Parallelisation}

\section{Routine}
\section{Subroutine}


\subsection{Allocation Overhead}
\subsection{Ownership}

std::make\_unique, ensure that the ownership of the dynamically allocated object is well-managed 


\begin{verbatim}
#include <memory>

int main() {
    std::unique_ptr<int> num_ptr = std::make_unique<int>(42);
    // num_ptr owns the dynamically allocated integer

    // ...
    
    return 0;
}
\end{verbatim}


\subsection{Turing Complete}


\subsection{Guaranteed Copy Elision}

Compilers have "always done copy elision on return values but c++17 guarantees it in some situations:

\begin{verbatim}
struct S {
    S() = default;
    S(S&&) = delete;
    S(const S &) = delete;
};

auto s_factory(){
    return S{}; // compiles in C++17, neither a copy nor a move.
}
\end{verbatim}

