\chapter{C++ Basics}

\section{Variables}
%keywords:variable,vars,var

\begin{verbatim}
    int: integers                   // 4 bytes
    double: floating-point numbers  // double 8 bytes
    char: individual characters     // 1 byte
    float:                          // 4 bytes
    long:                           // 4 or 8 bytes (platform dependent)
    long long:                      // 8 bytes
    bool: true/false                // 1 byte

    // use sizeof for size

std::cout << "Size of int: " << sizeof(numInt); 
\end{verbatim}

\section{Auto}
%keywords:aut

Automatic deduction of value types. Standard c++11

\begin{verbatim}
const auto radius = 1.5;
const auto area = pi * radius * radius;
std::cout << area;

// east/ west const
const auto result = std::count( /*stuff */);
auto const result = std::count( /*stuff*/ );
\end{verbatim}

\section{Synthax}
\subsection{Ternary Operator}
%keywords:ternary operator,ternaryoperator,ternaryop,ternoperator,ternary,tern,ternop  

\begin{verbatim}
std::cout << (coin == 0 ? "Heads" : "Tails") << "\n";
\end{verbatim}

\subsection{Relational Operators}

\begin{verbatim}
    ==              equal to
    !=              not equal to
    >               greater than
    <               less than
    >=              greater than or equal to
    <=              less than or equal to
\end{verbatim}

\subsection{Logical Operators}

\begin{verbatim}
    &&              and 
    ||              or
    !               not

    if (hunger && anger){}

    ( !true )       not false
    ( !(10 < 11) )  not condition 
\end{verbatim}

\subsection{String Manipulation}

\begin{verbatim}
reversed_text += text

std::string chapOnePath = parentDirectory + "/chap_1";
\end{verbatim}

\subsection{Scope}
%keywords:outofscope,outscope,inscope,scopes,scop

\begin{verbatim}
run() {
    {
        this is scope
    {
    
}
\end{verbatim}

\subsection{Chaining}
%keywords:chains,chain streams

\begin{verbatim}
operation.add(3).multiply(2).print();
\end{verbatim}

\section{Streams} 
%keywords:streams,stream,strea

\begin{verbatim}
    std::cin            : Standard input stream for reading user input.
    std::cout           : Standard output stream for writing output.
    std::cerr           : Standard error stream for writing error messages (unbuffered).
    std::clog           : Standard error stream for writing log messages (buffered).
    std::ifstream       : Input file stream for reading from files.
    std::ofstream       : Output file stream for writing to files.
    std::fstream        : File stream for reading from and writing to files.
    std::istringstream  : Input string stream for reading from strings.
    std::ostringstream  : Output string stream for writing to strings.
    std::stringstream   : String stream for reading from and writing to strings.
    std::wcin           : Wide character version of std::cin for reading wide characters.
    std::wcout          : Wide character version of std::cout for writing wide characters.
    std::wcerr          : Wide character version of std::cerr for writing wide error messages.
    std::wclog          : Wide character version of std::clog for writing wide log messages.
\end{verbatim}

\subsection{Sstream}
%keywords:sstrea,sstreams

`std::stringstream` is a C++ class. It handling string-based input and output operations,
allowing you to read from and write to strings as if they were input/output streams.

\begin{verbatim}
std::map<std::string, int> wordfreq;
std::istringstream iss(text);
std::string word;

while (iss >> word) {
    wordfreq[word]++;
}
\end{verbatim}

\section{Touples}
%keywords:touple,toup

\begin{verbatim}
no examples yet.
\end{verbatim}


\section{Enums}
%keywords:enum,enus,enu

\begin{verbatim}
enum class Day {
    Monday,
    Tuesday,
    Wednesday,
};

Day today = Day::Tuesday;

if (today == Day::Saturday || today == Day::Wednesday) {
} else {}
\end{verbatim}

\subsection{Enum Array Mapping}
%keywords:enumsarrays,enumsarray,enumarrays,enumarray,enumar,enuma

\begin{verbatim}
enum class Fruit {
    Apple,
    Banana,
    Orange
};

const std::array<std::string, 3> fruitNames = {
    "Apple",
    "Banana",
    "Orange"
}

    Fruit selectedFruit = Fruit::Banana;
    int fruitIndex = static_cast<int>(selectedFruit);
    std::cout << fruitNames[fruitIndex];
\end{verbatim}

\subsection{Enum Vector Mapping}
%keywords:enumsvectors,enumsvector,enumvectors,enumvector,enumvect,enumvec,enumv

\begin{verbatim}
enum class Month {
    January,
    February,
    March
};

const std::vector<std::string> monthNames = {
    "January",
    "February",
    "March"
};

    Month currentMonth = Month::May;
    int monthIndex = static_cast<int>(currentMonth);
    std::cout << "Current month: " << monthNames[monthIndex] << std::endl;
\end{verbatim}

\section{Arrays}
%keywords:array,arr,arra 

A fixed-size stack-based container. Having the size type information gives more optimization oppotunities.

\begin{verbatim}
    std::array<char, 128> second = {'H', 'e', 'l'} // from library
                            // fixed size of 128
                            // has .begin(), .end(), .at(), .size() 

    sint arr[] = {1, 2, 3}; // c-style array 
\end{verbatim}

\subsection{Dynamic Array Allocation}
%keywords:dynamicarrayallocation,allocatedynamicarray,dynamicarrays,dynamicarray,dynarrays,dynarray,darrays,darray

Achieved using pointers and dynamic memory allocation operators, such as `new` and `delete`. 
While arrays are considered static containers,
dynamic arrays allow you to allocate memory at runtime.

\begin{verbatim}
int size = 5;                      // desired size of the array
int* dynamicArray = new int[size]; // allocate memory for the array

std::array<int, 3> ar{1,2,3};

int* dyn_ar = new int[4];
delete[] dyn_ar;
\end{verbatim}

`new int[size]` dynamically allocates memory. 
`delete[] dynamicArray` deallocates the memory to avoid memory leaks.

Alternatively, using smart pointers or container classes like `std::vector` can help automate memory management
and provide safer alternatives for dynamic arrays.

\section{Vectors}
%keywords:vector,vect,vec

Vectors are \textbf{dynamic array-like container that can grow or shrink.}

\begin{verbatim}
std::vector<char> vowels = {'a', 'e', 'i', 'o', 'u'};
std::vector vec{1,2,3}; // now possible! 
\end{verbatim}

\section{Size\_t}
%keywords:sizet,sizt,st

\begin{verbatim}
for (size_t i = 0; i < array.size(); i++) 
\end{verbatim}

By using `std::size\_t` as the parameter type, 
it ensures that the value provided for `size` is appropriate for representing the size of the array.

The size of the array is specified as the value of `size`, which is of type `std::size\_t`. 
This ensures that the correct amount of memory is allocated for the array based on the given size.

\section{Iterators}
\subsection{Conditionals}
%keywords:conditional,conditions,condition,if,elseif,elsif,con,cond

\begin{verbatim}
if (coin == 0) {
} else {}
}
\end{verbatim}

\subsection{Switch Statements}
%keywords:switchstatement,casestatement,case,switch

\begin{verbatim}
  int number = 9;
  switch(number) {
    case 1 :
      std::cout << "case one";
      break;
    case 2 :
      break;
    default :
      break;
  }
\end{verbatim}

\subsection{Loops}
%keywords:iteration,iterate,iterator,iterators,iterating,loop,lop

\begin{verbatim}
for (int i = 0; i < 20; i++) {}  // incrementing
for (int i = 20; i > 0; i--) {}  // decrementing
\end{verbatim}

\section{Ranges}
%keywords:range,ran

\begin{verbatim}
for (const auto &element : container) {}
\end{verbatim}

\subsection{Ranges Pipes}
%keywords:rangespipes,rangespipe,rangepipe,rangep,ranp

I are operators for composing ranges in C++20.

They chain range adaptors, transforming or filtering operations.
Pipes take the output of one range and passes it as the input to the next range adaptor,
allowing you to compose multiple operations on a range in a concise and readable way.

\begin{verbatim}
auto even = [](int i){ return 0 == i % 2; };
auto square = [](int i){ return i * i; };

for (int i : ints | std::view::filter(even) | std::view::transform(square)) {
    std::cout << i << ' ';
}
\end{verbatim}

\subsection{Range-Based for Loops}
%keywords:rangesloops,rangesloop,rangeloops,rangeloop,rloops,rloop  

Iterate over container elements (array, vector or std::list). It doesn't work for forward\_list.

Works with anything that has begin()
and end() members/functions, C-Style arrays and initializer lists.

\begin{verbatim}
for (const auto &element : container) {}
for (char character : str) {}
for (const auto &value : container) {} // for each element in the container
\end{verbatim}

\section{Functions}
%keywords:function,func,fun

\begin{verbatim}
void eat() {
  std::cout << "nom nom\n";
}

bool even(int num) {
  return ( num % 2 == 0 ? true : false );
}
\end{verbatim}

\subsection{Inline Functions}
%keywords:inlinefunctions,inlinefunction,inlinefun,inlinef,inline,inli,inl

The compiler inserts the functionâ€™s body on the function call.

\begin{verbatim}
-- in .hpp -- 
inline 
void eat() {
  std::cout << "nom nom\n";
}

inline
std::string goodnight1(std::string thing1) {}
\end{verbatim}

\subsection{Member Functions}
%keywords:memberfunction,memfunction,member,mem,member,memfun,classfunction,classfunctions,classfunc,classfun,publicfunction,publicfun,pubfunc,pubfun,public,pub

Functions inside of classes.

\begin{verbatim}
class Musician {
private:
    int instruments;

public:
    int getMyVariable() const {
        return myVariable;
    }

    void setMyVariable(int newValue) {
        myVariable = newValue;
    }
};
\end{verbatim}

\subsection{Public Functions}
%keywords:publicfunction,publicfun,pubfunc,pubfun,public,pub

\begin{verbatim}
-- in .h --
class City {
  int population; 
 
public:         // accessible outside of the class
  void add_resident() { 
    population++;
  }
};
\end{verbatim}

\subsection{Overloading Functions}
%keywords:functionoverload,functionoverloading,funoverload,funoverloading,overfunction,overload,overloading,overloaded,overfun,over

Accepts many types as parameters.

Change behavior based on parameter's type.

\begin{verbatim}
// one must be true
Each has different type parameters.
Each has a different number of parameters.
    
// different number of params.
int fancy_number(int num1, int num2) {}
int fancy_number(int num1, int num2, int num3) {}
// different type of params.
int fancy_number(double num1, double num2) {}
\end{verbatim}

\section{Parameters}
%keywords:parameter,params,param,pars,par

\begin{verbatim}
void get_emergency_number(std::string emergency_number) {}
double get_tip(const MyType& price,bool total_included) {}
\end{verbatim}

\subsection{Pass-By-Value}
%keywords:passbyvalue,passvalue,passbyval,byvalue,byval

Passing by value makes modification impossible, since the passed variable is out of scope.
Pass by reference to modify the passed parameter.

\begin{verbatim}
void useless_fun(int val) {} // not modifiable
\end{verbatim}

\subsection{Pass-By-Reference}
%keywords:passingbyreference,passingreference,passbyreference,passreference,passbyref,passrefs,passref,byreference,byref

Modify the argument's value.
Avoid making copies of a variable/object for performance reasons.

\begin{verbatim}
void swap_num(int &i, int &j) {}
\end{verbatim}

\subsection{Parameters Default Values}
%keywords:defaultparameter,defaultparams,defaultarguments,defaultargument,defaultarg,default

\begin{verbatim}
struct Chapters {
    bool IsToPrint = true;
    // or
    Chapters() : IsToPrint(true) {} // with default constructor
};
\end{verbatim}

\subsection{Default Arguments}
%keywords:defaultarguments,defaultargument,defaultarg,default

\begin{verbatim}
void intro(std::string name, std::string lang = "C++");
\end{verbatim}

\section{References}

\subsection{References Variables}
%keywords:references,reference,refer,ref  

Using a reference (\&) instead of making a copy of the elements is more efficient,
especially when dealing with large objects or containers. 

By using a reference, the loop avoids creating a new copy of each element
, reducing unnecessary memory usage and improving performance.

\textbf{A second name for an existing variable}.

\begin{verbatim}
int soda = 99;
int &pop = soda;
pop++; // soda and pop equal at 100
\end{verbatim}

\subsection{Dereference}
%keywords:dereferencing,unreference,deref,unref

Obtain the pointer's pointed value. 

\begin{verbatim}
int power = 9000; // in declaration * is a ptr
                  // else * is memory address
int* ptr = &power;
\end{verbatim}

\subsection{Pass-By-Reference}
%keywords:passingbyreference,passingreference,passbyreference,passreference,passbyref,passrefs,passref,byreference,byref

Now, when called, the function can modify the argument's value.
Avoid making copies of a variable/object for performance reasons.

\begin{verbatim}
void swap_num(int &i, int &j) {} // modifiable
\end{verbatim}

\subsection{References Const}
%keywords:constreferences,constreference,referencesconst,referenceconst,constrefs,constref 

\begin{verbatim}
int triple(const int &i) {} // doesn't copy element
                            // ref won't change
\end{verbatim}

\subsection{Reference Operator}
%keywords:refoperator,refop

\begin{verbatim}
int soda = 99; 
int &pop = soda;
pop++;
\end{verbatim}

\subsection{Address Operator}
%keywords:addressoperator,addressop,address,add

\begin{verbatim}
int porcupine = 3; 
std::cout << &porcupine << "\n"; 

// 0x7ffd7caa5b54
\end{verbatim}

\chapter{Memory Allocation}
\section{Pointers}
%keywords:pointer,point

\begin{verbatim}
int* number;         // Declaring
double* decimal;

int gum = 8;
int* ptr = &gum;     // int* [declare a pointer]
                     // ptr [pointer's name]
                     // &gum [store gum's memory address in ptr]

int* number;         // Declaration standard
int *number;
int * number;        // All Synthaxically valid
\end{verbatim}

\subsection{Null Pointers}
%keywords:nullpointers,nullpointer,nullpoint,pointnull

Ptr to a yet unknown memory address.

\begin{verbatim}
int* ptr; // declared, not yet initialized
\end{verbatim}

\subsection{Nullptr}
%keywords:nulptr,nullp,null

Type safe pointer since C++14, I think. A replacement for NULL.

\begin{verbatim}
int* ptr = nullptr;
\end{verbatim}

\subsection{Unique Pointers}
%keywords:uniquepointers,uniquepointer,uniquepoint,makeunique,uniqueptr,unique

\begin{verbatim}
std::unique_ptr<int> num_ptr = std::make_unique<int>(42);
// num_ptr owns the dynamically allocated integer
\end{verbatim}

\subsection{Smart Pointers}
%keywords:smartpointers,smartpointer,smartptr,smart,
\begin{verbatim}
No notes on smart pointers yet.
\end{verbatim}

\subsection{Pointer of Pointer}
%keywords:pointerofpointer,pointerpointer,pointtopointer,pointtopoint,pointpoint

\begin{verbatim}
int value = 5;
int* ptr = &value;
int** ptrToPtr = &ptr;
\end{verbatim}

\subsection{Allocation}
%keywords:allocations,allocating,allocate,allo

\begin{verbatim}
No notes on allocation yet.
\end{verbatim}

\subsection{Deallocation}
%keywords:deallocating,deallocations,deallocated,deallocate,deal

\begin{verbatim}
No notes on deallocation yet.
\end{verbatim}

\subsection{Freeing Memory}
%keywords:free,freeing

\begin{verbatim}
No notes on freeing memory yet.
\end{verbatim}

\subsection{Leaking Memory}
%keywords:leakingmemory,leaking,leaks,leak 
\begin{verbatim}
No notes on leaking yet.
\end{verbatim}

\section{Classes}
%keywords:class,clas,cla

\begin{verbatim}
class City { // user-defined type.
};
\end{verbatim}

\subsection{Class Components}
%keywords:classcomponents,classcomponent,clascomponent,clacomponent,classcomp,components,component

\begin{verbatim}
class City {
  int population;       // attribute
 
public:
  void add_resident() { // method
    population++;
  }
};
\end{verbatim}

\section{Span}
%keywords:spans,spa

A non-owning, lightweight and flexible view over a contiguous sequence of elements.
A `span` is a pointer to the first element and the number of elements in the sequence.
A non-owning view, \textbf{it can be used to work with the array without copying its elements}.

Pass and manipulate data ranges, such as sub-arrays or portions of containers,
without memory allocation overhead or ownership.

It allows you to write generic functions that operate on different containers
without requiring specific container types.

\begin{verbatim}
#include <span>

void printSpan(std::span<int> sp) {
    for (int element : sp) {}
}
\end{verbatim}

\section{Templates}
%keywords:template,templat,temps,temp

The ultimate in the DRY principle. Write a template that has types and values filled in at compile-time.
template types are generated by the compiler at compile time
. Do not need any kind of type-erasure (like Java generics do)

Highly efficient runtime code possible, 
as good as (or better than) hand writing the various options

\begin{verbatim}
template<typename SomeType>
struct S { // struct can do anything it wants with this type
};

template <typename meaningful_Type>
meaningful_Type get_smallest(meaningful_Type num1, meaningful_Type num2) {
  return num2 < num1? num2 : num1;
}
\end{verbatim}

\subsection{Templates Basics}
%keywords:basictemplate,templatebasics,tempbasics,basicstemp,basictemp  

\begin{verbatim}
template<typename T>
T divide(T numerator, T denominator) {
    return numerator / denominator;
}
\end{verbatim}

\subsection{Variadic Templates}
%keywords:variadictemplate,variatemplates,variatemplate,variadictemp,variatemp,variadic,varia  

Drastic simplification of code needing to match a variable number of parameters.

\begin{verbatim}
template<typename VT, typename ... Params>
std::array<VT, sizeof...(Params)+1> get_data(const VT &v1, const Params& ...params)
{
    return {v1, params...};
}
\end{verbatim}

\subsection{CTAD - Class Template Argument Deduction}
%keywords:classtemplates,classtemplate,classtemp,ctad 

\begin{verbatim}
template<typename VT, typename ... Params>
auto get_data(const VT &v1, const Params & ... params)
{
    return std::array{v1, params...}; // auto deduced size/type
}
\end{verbatim}

\subsection{Templates Auto Return Types}
%keywords:autotemplates,autotemplate,templateauto,autotemp,tempauto  

\begin{verbatim}
template<typename Numerator, typename Denominator>
auto divide(Numerator numerator, Denominator denominator)
{
    return numerator / denominator;
}
\end{verbatim}


\subsection{Return Value Optimization}
RVO, a compiler optimization technique on 
unnecessary object copies when returning.


When a function returns an object by value,
the traditional behavior involves creating a temporary object to hold 
the returned value and then copying that temporary object to the caller's destination object.


RVO directly constructs the return value object in the memory allocated by the caller.
This avoids the temporary object creation and data copy.

\section{Structs}
%keywords:struct,s

The only difference between a struct and a class is public properties. With
structs, all properties are public by default.

\begin{verbatim}
struct Double_Data {
    Double_Data(const std::size_t size) : data(new double[size] { }
    ~Double_Data() { delete [] data; }
    double *data;
   };
\end{verbatim}

\subsection{Structs Against Classes}
%keywords:structsvsclasses,structsandclasses,classesandstructs,structsandclasses,structsclasses,structclasses,structvsclass,structclass,classesvsstructs,classesvsstruct,classstruct

\begin{verbatim}
The only difference between them is that struct has all members by default public.
Using struct makes examples shorter and easier to read. 
\end{verbatim}

\section{Lambdas}
%keywords:lambda,lambd,lamb,lam

Unnamed function objects occasionally capturing.

\begin{verbatim}
auto lambda = [/*captures*/](int param1){ return param1 * 10; };
auto even = [](int i){ return 0 == i % 2; };
auto square = [](int i){ return i * i; }; 
\end{verbatim}

\subsection{Lambdas Captures by Values}
%keywords:capturebyvalue,capturebyval,capturingbyvalue,capturingbyval,capturingval,capturevalue,captureval  

A copy of the variable is made.

\begin{verbatim}
auto lambda = [param](int param1){ return param1 * 10; };
\end{verbatim}

\subsection{Lambdas Captures References}
%keywords:capturebyreferences,capturebyreference,capturereferences,capturereference,capturerefs,captureref,capturingbyreferences,capturingbyreference,capturingreferences,capturingreference,capturingrefs,capturingref

\begin{verbatim}
auto lambda = [&param](int param1){ return param1 * 10; };
\end{verbatim}

\subsection{Lambdas Captures by Values and References}
%keywords:capturingboth,capturesboth,captureboth,bothcaptures,bothcapture  

Capture multiple variables, 

\begin{verbatim}
auto lambda = [x, &y](int param1){ return x * param1 + y; };
    // x is captured by value, creating a copy
    // y is captured by reference, with access to original
\end{verbatim}

\subsection{Lambda Auto}
%keywords:lambdasauto,lambdaauto,lambauto,autolambdas,autolambda,autolamb

\begin{verbatim}
[&](auto &data) {} // makes a generic lambda, I think
\end{verbatim}

\subsection{Lambdas Generic Lambdas}
%keywords:genericlambdas,genericlambda,genericlamb,genlambdas,genlamb  

Create implicit templates by simply using the auto keyword.

\begin{verbatim}
auto lambda = [/*captures*/](auto ... params){}
\end{verbatim}

\subsection{Variadic Lambdas}
%keywords:variadiclambda,varialambda,varialamb,varlambdas,varlambda,varlamb  

\begin{verbatim}
no examples yet.
\end{verbatim}

\subsection{Const Lambdas}
%keywords:constlambdas,constlambda,constlamb,lambdasconst,lambdaconst,lambconst

\begin{verbatim}
const auto data = [](){}(); // immediately invoked
\end{verbatim}

\section{Concepts}
%keywords:concept,conc

I want to have two versions of a function, one takes a Floating Point, the other an Integral value.
Allows us to specify the requirements for a type, implicitly creating a template
that constrains how a function can be used. Standard: C++20

\begin{verbatim}
#include <concepts>

auto func(std::floating_point auto f) { return f * 3; }
auto func(std::integral auto i) { return i + 3; }
\end{verbatim}

\section{Constants}
%keywords:constant,consts,const,cons

The most important tool to write clean code.
An object declared const or accessed via a const referece or const pointer cannot be modified.
It forces us to think about initialization and lifetime of objects, which affects performance. 

Plus, it communicates meaning to readers. 
If a variable is not const, ask why not?
Would using a lambda or adding a named function allow you to make the value const?

\begin{verbatim}
const double radius = 1.5;
const double area = pi * radius * radius;

// east const or west const, the same
const int i = 5;
int const j = 6;
\end{verbatim}

\subsection{Const Char}
%keywords:constchar,charconst

\begin{verbatim}
#include <filesystem>
namespace fs = std::filesystem;

fs::path path = "your_directory_path";

for (const auto &entry : fs::directory_iterator(path)) {
    const char *cstr = entry.path().c_str();
    std::cout << cstr << '\n';
}
\end{verbatim}

\section{Constexpr}
%keywords:constexp,constex,conste,contexp,contex,conte

Compile-time generation of code and data. Compile-time constant.

\begin{verbatim}
constexpr double pi = 3.141593; // compile-time generation of code
                                // compile-time constant
\end{verbatim}

\section{Memory Allocation}

\begin{verbatim}
int porcupine = 3;
std::cout << &porcupine << "\n"; // Memory address
                                 // 0x7ffd7caa5b54

Dynamic Memory Allocation

int main() {
    int size = 5;
    int* dynamicArray = new int[size];

    for (int i = 0; i < size; ++i) {
        dynamicArray[i] = i + 1;
    }

    for (int i = 0; i < size; ++i) {
        std::cout << dynamicArray[i] << " ";
    }

    delete[] dynamicArray;
    return 0;
}
\end{verbatim}

\section{Factories}
%keywords:factory,fact,fac

Design pattern.

\begin{verbatim}
struct S {
    S() = default;
    S(S&&) = delete;
    S(const S &) = delete;
};

auto s_factory(){
    return S{}; // compiles in C++17, neither a copy nor a move.
}
\end{verbatim}

Here, a factory class (`Factory`) that creates different types of products
(`ConcreteProductA` and `ConcreteProductB`) derived from an abstract base class `Product`.
The factory's `createProduct` method takes a product type as input and returns a unique pointer to the created product.
The main function creates instances of `ConcreteProductA` and `ConcreteProductB` through the factory.

\subsection{Virtual Factories}
%keywords:virtualfactories,virtualfactory,virtualfac,virtfac,virt

A virtual factory is a design pattern that uses virtual functions and 
polymorphism to create objects of different types through a common interface.
Polymorphism is the ability of an object to take on many forms
and behave differently based on the context or the type of object it is being accessed through.

\begin{verbatim}
No good examples yet.
\end{verbatim}

Here, an abstract factory class (`AbstractFactory`) that defines the interface for creating products.
The concrete factory classes (`ConcreteFactoryA` and `ConcreteFactoryB`) implement
implement the createProduct method to create specific products (ConcreteProductA and ConcreteProductB, respectively).
The main function demonstrates the usage of 
the virtual factory by creating instances of the concrete factories and using them to create products.

\chapter{Object Lifetime}

\section{Constructors}
%keywords:constructing,construction,constructed,constructor,construct

\begin{verbatim}
public:
  City(std::string new_name, int new_pop); // constructor
  ~City();  // destructor
};
\end{verbatim}

\section{Destructors}
%keywords:destruction,destructing,destructor,destruct,destroy

\begin{verbatim}
  City(std::string new_name, int new_pop);
  ~City();  // destructor
\end{verbatim}

\subsection{Automatic Destructors}
%keywords:automaticdestructor,automaticdestruction,autodestruction,autodestructor,autodestruct,autodestroy  

\begin{verbatim}
The object moves out of scope.
The object is explicitly deleted.
When the program ends.

void some_func() {
    std::string s{"Hello"};     // allocate a string
}                               // automatically frees it
                                // when scope exits
\end{verbatim}

\subsection{Deterministic Object Lifetime and Destruction}
%keywords:deterministic,determinism,deter

Constructor / Destruct pairs (RAII) combined with scoped values give us determinism.

\begin{verbatim}
void some_func() {
    std::string s{"Hello"};     // allocate a string
}                               // automatically frees it
                                // when scope exits
\end{verbatim}


\subsection{RAII}

Constructor and Destructor pairs? I need more on this.

\subsection{New Keyword}
%keywords:new

\begin{verbatim}
std::array<int, 3> ar{1,2,3};
int* dyn_ar = new int[4];
\end{verbatim}



\subsection{Automatic}

\begin{verbatim}

For format see p.44 filetime puzzler book 1

S object_1("a","t");
\end{verbatim}

\subsection{Thread\_local}
%keywords:threadlocal,localthread,thread
\begin{verbatim}
thread_local object_2("a","t");
\end{verbatim}

\subsection{Static}
%keywords:staticobjects,staticobject,statics,stat 
\begin{verbatim}
static object_3("a","t");
\end{verbatim}

\subsection{Dynamic}
%keywords:dynamicobjects,dynamicobject,dynam,dyn

\begin{verbatim}
delete new S *object_4("a","t");
\end{verbatim}

\chapter{Libraries}

A collection of pre-compiled code, providing functionality. Functions, classes and data structures,
that are not part of the standard C++ library.

\section{fmt format library}
%keywords:fmtformat,fmtlibrary,fmtlib,fmt

\begin{verbatim}
No good example for fmt.
\end{verbatim}
\subsection{String\_View}
%keywords:stringview,viewstring,

Observe string-like things without actually constructing a std::string!
A non-owning "view" of a string like structure.

\begin{verbatim}
#include <string_view>
std::string_view sv{some_string_like_thing}; // no copy

These are passed-by-value on purpose.
String_view are cheap to copy. It is recommended to pass them by value.
\end{verbatim}

\subsection{Text Formatting}

A subset of the excellent {fmt} library, allowing for formatting of strings with positional,
named and python/printf style formatting options.

\begin{verbatim}
#include <format>
std::string s = fmt::format("I'd rathe be {1} than {0}.", "right", "happy");
// "I'd rather be happy than right."
\end{verbatim}

\section{Structured Bindings}
%keywords:structuredbindings,structuredbinding,structurebindings,structurebinding,structbindings,structbinding,bindings,binding,

Used to decompose a structure or array into a set of identifiers.
You must use auto, and the number of elements must match. There's no way to skip an element.

\begin{verbatim}
const auto &[elem1, elem2] = some_thing;

template<typename Map>
void print_map(const Map &map, const std::string &key_desc = "key",
                               const std::string &value_desc = "value")
{
    for (const auto &[key, value] : map) // structured binding
\end{verbatim}

\section{Arguments}
%keywords:argument,args,arg

\begin{verbatim}
int main(int argc, char* argv[]) {
    std::vector<std::string> arguments(argv + 1, argv + argc);
    
    const auto first_argument = arguments[0];

    return 0;
}
\end{verbatim}

\subsection{Flags}
%keywords:options,option,flag

\begin{verbatim}
bool hasFlag(const std::vector<std::string>& arguments, const std::string& flag) {
    return std::find(arguments.begin(), arguments.end(), flag) != arguments.end();
}

int main(int argc, char* argv[]) {
    std::vector<std::string> arguments(argv + 1, argv + argc);

    if (arguments.size() == 0) {
        arguments.push_back("-help");
    }

    if (hasFlag(arguments, "-o")) {
        std::cout << "Flag -o for -omit is present!" << std::endl;
    }
\end{verbatim}

\subsection{User Input}
%keywords:promptuser,askuser,userresponse,useranswer,prompting,prompt,answer,user  

\begin{verbatim}
std::cout << "Enter your password: ";
std::cin >> password;

#include <cstdlib>
std::string answer;
std::cout << "Place the output in" << output_dir << "? [y/yes, n/no]: ";
std::cin >> answer;

if (answer == "y" || answer == "yes") {
} else if (answer == "n" || answer == "no") {
} else {
    std::cout << "Invalid response, exiting";
    std::exit(1) // (failure)
}
\end{verbatim}

\section{Type}

\subsection{Return Types}
%keywords:returntypes,returntype,returns,return 

\begin{verbatim}
  std::exit(0) (success)
  std::exit(1) (failure)
\end{verbatim}

\chapter{Filesystem Library}
%keywords:filesystemlibrary,filelibrary,filelib,filesystem,filesys,fs

LOOK AT FILESYSTEM VIDEO IN CODE

Introduced in c++17, the language has a filesystem library allowing
manipulation of paths, regular files and directories.

\section{Files}

\subsection{File Creation}
%keywords:filecreation,createfiles,createafile,createfile,newfile 

Use the fstream header and the ofstream function.

\begin{verbatim}
#include <filesystem>
#include <fstream> // Add this header for std::ofstream
namespace fs = std::filesystem;

fs::create_directories("sandbox/a");
std::ofstream("sandbox/file.1.txt");     // is simplest, deletes instantly
std::ofstream file("sandbox/file1.txt"); // initialize the variable on top!

// Check if the file was opened successfully
if (file.is_open()) {
    file << "This is some content written to the file.\n";
    file.close(); // Close the file after writing if no longer needed
} else {
    std::cout << "Failed to open the file.\n";
}
\end{verbatim}

\subsection{File Deletion}
%keywords:filedeletions,filedeletion,removefiles,removefile,deletefile,deleteafile,rm
\begin{verbatim}
No good example for file deletion.
\end{verbatim}


\section{Paths}

\begin{verbatim}
No good example for paths.
\end{verbatim}

\section{Directories}
%keywords:removedirectory,removedir,directory,rmdir,dir

\begin{verbatim}
No good example for directories.
\end{verbatim}

\subsection{Directory Creation}
%keywords:createdirectory,createdirectory,createdir,newdirectory,newdir,mkdir  

Create a directory with fs::create\_directories. This creates both sandbox and a, inside it.

\begin{verbatim}
#include <filesystem>
#include <fstream>
namespace fs = std::filesystem;

int main() {

    fs::create_directories("sandbox/a");
    std::ofstream("sandbox/file1.txt");
    std::ofstream("sandbox/file2.txt");

    for (auto& p : fs::directory_iterator("sandbox")) {
        std::cout << p.path() << '\n';
    } 

fs::remove_all("sandbox");

}
\end{verbatim}

\subsection{Directory Iterators}
%keywords:directoryiterators,directoryiterator,diriterators,diriterator,diriterate  

\begin{verbatim}
#include <filesystem>
namespace fs = std::filesystem;

std::string path = "./foo";
for (const auto &entry : fs::directory_iterator(path))
    std::cout << entry.path();
\end{verbatim}

\subsection{Chrono, clock time}
%keywords:clock,chrono,chron,timesomething,timefunction,functiontime,

\begin{verbatim}
#include <chrono>
std::chrono::high_resolution_clock::time_point start = std::chrono::high_resolution_clock::now();
    // function
std::chrono::high_resolution_clock::time_point end = std::chrono::high_resolution_clock::now();
std::chrono::duration<double, std::milli> time_span = end - start;

std::cout << "Time taken for goodnight1(): " << time_span.count() << " milliseconds.\n\n";
\end{verbatim}

\chapter{Compilers}
%keywords:compilers,compiler,compile
\begin{verbatim}
No examples for compilers.
\end{verbatim}

\section{Compiler GNU GCC}
%keywords:gnucompiler,gnucompile,gnugcc,gnuc,gnu,gcc

\begin{verbatim}
alias g++="g++ -Wall -Werror -Wextra -pedantic -std=c++17"
\end{verbatim}

\subsection{GNU GCC Enable Precompiled Headers}
%keywords:gccprecompileheaders,gccprecompileheader,gccprecompile,precompileheadersgcc,precompileheadergcc,precompilegcc,gccenablepch,enablegccpch,enablepchgcc  

\begin{verbatim}
no examples yet
\end{verbatim}

\subsection{GNU GCC Enable Warning as Errors}
%keywords:gccwarningsaserror,gccwarningsaserrors,gccwarningserrors,gccwarningserror,gccwarnings,gccwarning,gccaserrors,gccaserror,gccerrors 

\begin{verbatim}
no examples yet
\end{verbatim}

\subsection{GNU GCC Disable Extensions}
%keywords:gccdisableextensions,gccnoextensions,gccextensions,gccremoveextensions,gccremoveextension,gccdisablext 

\begin{verbatim}
no examples yet.
\end{verbatim}

\section{Compiler LLVM Clang}
%keywords:clang

\begin{verbatim}
no examples yet.
\end{verbatim}

\subsection{Clang Enable Precompiled Headers}
%keywords:clangprecompileheaders,clangprecompileheader,clangprecompile,precompileheadersclang,precompileheaderclang,precompileclang,clangenablepch,enableclangpch,enablepchclang  

\begin{verbatim}
no examples yet.
\end{verbatim}

\subsection{Clang Enable Warning as Errors}
%keywords:clangwarningsaserror,clangwarningsaserrors,clangwarningserrors,clangwarningserror,clangwarnings,clangwarning,clangaserrors,clangaserror,clangerrors 

\begin{verbatim}
no examples yet.
\end{verbatim}

\subsection{Clang Disable Extensions}
%keywords:gccdisableextensions,gccnoextensions,gccextensions,gccremoveextensions,gccremoveextension,gccdisablext 

\begin{verbatim}
no examples yet
\end{verbatim}

\subsection{Clang-Format}
%keywords:clangformat,formatclang

\begin{verbatim}
no examples yet
\end{verbatim}

\subsection{Clang-tidy}
%keywords:clangtid,clangtidy,tidy

\begin{verbatim}
no examples yet
\end{verbatim}


\section{Compiler MSVC}
%keywords:microsoftcompiler

\begin{verbatim}
no examples yet
\end{verbatim}

\subsection{MSVC Enable Precompiled Headers}
%keywords:msvcprecompileheaders,msvcprecompileheader,msvcprecompile,precompileheadersmsvc,precompileheadermsvc,precompilemsvc,msvcenablepch,enablemsvcpch,enablepchmsvc

\begin{verbatim}
no examples yet
\end{verbatim}

\subsection{MSVC Enable Warning as Errors}
%keywords:msvcdisableextensions,msvcnoextensions,msvcextensions,msvcremoveextensions,msvcremoveextension,msvcdisablext 

\begin{verbatim}
no examples yet
\end{verbatim}

\subsection{MSVC Disable Extensions}
%keywords:msvcdisableextensions,msvcnoextensions,msvcextensions,msvcremoveextensions,msvcremoveextension,msvcdisablext 

\begin{verbatim}
no examples yet
\end{verbatim}
